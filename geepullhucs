var Landsat5 = ee.ImageCollection("LANDSAT/LT05/C01/T1_SR");
var Landsat7 = ee.ImageCollection("LANDSAT/LE07/C01/T1_SR");
var Landsat8 = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR");
var VA_Disturbance = ee.Image("users/cmwyatt5/Spring2019/Joby_Original_Map");
var VA_Thins = ee.Image("users/cmwyatt5/Spring2019/VA_3class_newcodes_Project");

var state = ee.FeatureCollection("TIGER/2018/States").filter(ee.Filter.eq("STATEFP", "51"));
var hucTEN = ee.FeatureCollection("USGS/WBD/2017/HUC10").filterBounds(state);

var whatyear = 10; // # years past clearcut
var howMuchBuff = -5; // # Meters to buffer in 
var areaThreshold = (30 * 30) * 9; // # meters for threshold

var clr_Mask = VA_Thins.eq(2);
var clearcut = VA_Thins.updateMask(clr_Mask);

var dist_Mask = VA_Disturbance.gt(13);
var dist_Mask2 = VA_Disturbance.lt(39); // This only for 10yr LAI
var std_clr = VA_Disturbance.updateMask(dist_Mask).updateMask(dist_Mask2);

var stdClr_and_clrCut = clearcut.and(std_clr);

var finalClrCut = clearcut.updateMask(stdClr_and_clrCut);
var finalStdClr = std_clr.updateMask(stdClr_and_clrCut);

function cloudMaskL457(image){
  var qa = image.select('pixel_qa'); 
  
  var cloudMed = qa.bitwiseAnd(1 << 5) // set qa bit to cloudy
          .and(qa.bitwiseAnd(1 << 7)) // get medium confidence cloud
          .or(qa.bitwiseAnd(1 << 3)) // or else cloud shadows
          .or(qa.bitwiseAnd(1 << 4));
            
  var mask2 = image.mask().reduce(ee.Reducer.min());
  
  return image //mask out high confidence clouds
              .updateMask(cloudMed.not()) // mask out medium confidence clouds
              .updateMask(mask2); // mask out surrounding pixels
}

function maskL8sr(image) {

  var qa = image.select('pixel_qa');

  var cloud = qa.bitwiseAnd(1 << 5) 
      .and(qa.bitwiseAnd(1 << 7)); 
      
  var cirrus = qa.bitwiseAnd((1 << 9)) 
      .and(qa.bitwiseAnd(1 << 5)); 
      
  var snow = qa.bitwiseAnd(1 << 4); 
  
  var shadow = qa.bitwiseAnd(1 << 3); 
  
  // Return the masked image
  return image.updateMask(cloud.not())
          .updateMask(cirrus.not())
          .updateMask(snow.not())
          .updateMask(shadow.not());
}


function simpleRatioL457(image){
  var ratio = image.expression(
      'NIR / RED ', {
        'NIR': image.select('B4'),
        'RED': image.select('B3')
  }).rename('simpleRatio');
  return image.addBands(ratio)
  .select('simpleRatio');
}

function simpleRatio8(image){
  var ratio = image.expression(
      'NIR / RED ', {
        'NIR': image.select('B5'),
        'RED': image.select('B4')
  }).rename('simpleRatio');
  return image.addBands(ratio)
  .select('simpleRatio');
}

var LAIfmSR = function(image){
  var LAI = image.expression(
    "SR * 0.3329155 - 0.00212", {
      "SR": image.select("simpleRatio")
    }).rename("LAI");
    return image.addBands(LAI)
    .select("LAI");
};

var Landsat5_LAI = Landsat5.map(cloudMaskL457).map(simpleRatioL457).map(LAIfmSR);

var Landsat7_LAI = Landsat7.map(cloudMaskL457).map(simpleRatioL457).map(LAIfmSR);

var Landsat8_LAI = Landsat8.map(maskL8sr).map(simpleRatio8).map(LAIfmSR);

var collection = Landsat5_LAI.merge(Landsat7_LAI).merge(Landsat8_LAI)
.sort("system:time_start");


var winterCollection = collection.filter(ee.Filter.calendarRange(2,2,'month'))
.filterBounds(state);

function pullHUC(huc){
  
  var vectorVersion = finalStdClr.reduceToVectors({
    scale: 10,
    geometryInNativeProjection: true,
    geometryType: "polygon",
    maxPixels: 5058413600,
    geometry: huc.geometry() // Define the limiting geometry
  });
  
  var buff = vectorVersion.geometry().buffer(howMuchBuff);
  var vectorCollection = ee.FeatureCollection(buff);
  var onlyPolys = vectorCollection.map(function(feat){
  feat = ee.Feature(feat);
  var geometries = feat.geometry().geometries(); 
  var extractPolys = ee.FeatureCollection(geometries.map(function(poly){
    poly = ee.Geometry.Polygon(ee.Geometry(poly).coordinates());

    return ee.Feature(poly);
  }));
  return extractPolys;
  }).flatten(); 
  var polysWithArea = onlyPolys.map(function(feature){
    return feature
    .set("ID", feature.id())
    .set("area", feature.geometry().area());
  });
  var areaSubset = polysWithArea.filter(ee.Filter.gt("area", areaThreshold));
  
  var disturbance_table = finalStdClr.reduceRegions({
    collection: areaSubset,
    reducer: ee.Reducer.mean()
  });

  function LAIatYrX(feat){
    var dist_code = feat.get("mean");
    
    var dist_year = ee.Number(dist_code).add(1970);
    
    var metric_year = dist_year.add(whatyear);
    
    var bounding_date1 = ee.String(metric_year.toInt()
                                   .subtract(1)).cat(ee.String("-11-30"));
    
    var bounding_date2 = ee.String(metric_year.toInt()).cat(ee.String("-03-01"));
    
    var year_collection = winterCollection
      .filterDate(bounding_date1, bounding_date2);
    
    var mean_LAI_feats = year_collection.map(function(image){
    
      var sens_time = ee.Date(image.get("SENSING_TIME"));
      
      var LAI = image.reduceRegion({
        reducer: ee.Reducer.mean(),
        geometry: feat.geometry()
      }).get("LAI");
      
      var out_feature = ee.Dictionary({
        "SENSING_TIME": sens_time,
        "LAI": LAI
      });
      
      return ee.Feature(feat.geometry(), out_feature);
    
    }).filter(ee.Filter.neq("LAI", null));
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    var max_lai = mean_LAI_feats.reduceColumns({
    reducer: ee.Reducer.max(),
    selectors: ["LAI"]
    }).get("max");
    
    return ee.Feature(feat.geometry(), {
      "code": dist_code,
      "dist_year": dist_year,
      "metric_year": metric_year,
      "max_lai": max_lai
    });
  }

  var YrX_LAI = disturbance_table.map(LAIatYrX).filter(ee.Filter.gte("max_lai", 0));
  
return YrX_LAI;
}

hucTEN = hucTEN.filter(ee.Filter.neq("huc10", "0301020205"));
var HUC_LAI = hucTEN.map(pullHUC); 
Map.addLayer(hucTEN);
// Map.addLayer(HUC_LAI);
// Export.table.toDrive(HUC_LAI.flatten()); 
Export.table.toDrive({
  collection: HUC_LAI.flatten(),
  description: "HUC10_Shapefile_wHucCut",
  folder: "HUC_shp_Exports",
  fileFormat: "SHP"
});
